# Plan: From Binary Expressions to Print Statements

## Phase 1: Create Statement Parser Foundation
[ ] **Add Print token to Scanner**
   - Extend Token.Tag enum with `.Print`
   - Add keyword recognition in scanner for "print"
   - Test that scanner properly tokenizes print statements

[ ] **Create StmtParser module structure**
   - New file: `StmtParser.zig` or integrate into `Comp.zig`
   - Define basic structure with scanner, diagnostics, chunk access
   - Decide on initialization pattern (similar to current Compiler.init?)

[ ] **Design statement identification logic**
   - How do you look ahead to determine statement type?
   - Switch on token types: `.Print` → print statement, others → expression statement?
   - Plan for future statement types (var, if, while, etc.)

[ ] **Create statement parsing loop**
   - Main parsing loop that consumes statements until EOF
   - Error recovery strategy: how do you sync after parse errors?
   - Semicolon handling: required? optional? error recovery point?

[ ] **Define statement result types**
   - What does each statement parsing function return?
   - Success/failure states, error propagation
   - How do you handle "statement consumed tokens but failed"?

## Phase 2: Implement Basic Print Statement Parsing
[ ] **Create `parseStatement()` function**
   - Top-level dispatch based on current token
   - Handle `.Print` case first, stub others as unimplemented

[ ] **Implement `parsePrintStatement()` function**
   - Consume `print` token
   - Identify that an expression should follow
   - Define what you expect back from expression parsing
   - Handle semicolon requirement

[ ] **Define ExprParser interface requirements**
   - What parameters does StmtParser need to pass to expression parsing?
   - What does StmtParser need back? (This drives your ExprResult design!)
   - How do you handle "parse expression starting from current token"?

## Phase 3: Design ExprResult Structure (Based on StmtParser needs)
[ ] **Define ExprResult type based on print statement needs**
   - For print: need the bytecode that produces a value on stack
   - Include success/failure state
   - Include any constants that need to be added to chunk
   - Location info for error reporting

[ ] **Design bytecode representation in ExprResult**
    - List of instruction bytes? Higher level instruction enum?
    - How do you handle instructions that reference constants?
    - Consider: separate instructions list + constants list?

[ ] **Plan ExprParser interface**
    - Function signature: `parseExpression(scanner, diagnostics, ...) ExprResult`
    - How does it advance tokens? Return new position?
    - Error handling: how does StmtParser know parsing failed?

## Phase 4: Extract and Refactor Current ExprParser
[ ] **Create new parseExpression function**
    - Copy current `:parse` logic but change output strategy
    - Instead of `self.emitByte()`, build ExprResult structure
    - Keep same parsing logic, just change what you do with results

[ ] **Handle constants in ExprResult**
    - When you encounter `.Number`, don't add to chunk immediately
    - Store constant value in ExprResult for StmtParser to handle
    - Design how constant references work in instruction stream

[ ] **Update precedence and operator handling**
    - Operator stack logic stays the same
    - Change final output: build instruction list instead of emitting
    - Handle operator precedence resolution in ExprResult building

## Phase 5: Wire StmtParser and ExprParser Together
[ ] **Implement StmtParser → ExprParser call**
    - Call parseExpression from parsePrintStatement
    - Handle ExprResult success/failure
    - Pass through scanner position, diagnostics properly

[ ] **Implement ExprResult → Bytecode emission**
    - In StmtParser: take ExprResult and emit actual bytecode
    - Add constants to chunk's constant pool
    - Emit instruction sequence that produces value on stack

[ ] **Add Print opcode and VM support**
    - Extend OpCode enum with `.Print`
    - Add VM case for Print: pop stack, output value
    - Update disassembler to handle Print instruction

## Phase 6: Integration and Main Entry Point
[ ] **Update main compile function**
    - Change from expression parsing entry to statement parsing entry
    - StmtParser becomes the top-level parser
    - Handle case where input is just expressions vs statements

[ ] **Test and iterate**
    - Simple cases: `print 42;`
    - Complex cases: `print 1 + 2 * 3;`
    - Error cases: `print ;`, `print 1 +`, missing semicolons
    - Refine interfaces based on what breaks

Starting with steps 1-5 will force you to think about what StmtParser needs from ExprParser!